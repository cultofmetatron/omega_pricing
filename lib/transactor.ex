defmodule PriceTracker.Transactor do
  @moduledoc """
    Transactor is in charge of storing the params generated by
    the requester into the database.

  """
  use PriceTracker.Headers, :transactor
  alias PriceTracker.Product
  alias PriceTracker.PastPriceRecord
  import Logger

  @doc """
    takes a list of products and merges them in

    TODO: This could be more efficiently be done with
    a pmap
  """
  def merge_products(products, repo) do
    statuses = products
      |> Enum.map(fn(product) -> merge_product(product, repo) end)
      |> log_transactions()

  end

  @doc """
    logs the diffrent transactions based on status
    runs for side effects
  """
  def log_transactions(statuses) do
    statuses
      |> Enum.map(&report_status/1)
    statuses
  end

  def report_status({:error, :name_for_product_changed, %{id: id, from: old_name, to: new_name }}) do
    Logger.warn("name_changed for product:#{id} from: #{old_name} to #{new_name}")
  end


  def report_status({:error, message, params}) do
    Logger.error fn () -> {message, [metadata: params]} end
  end

  def report_status({:error, message}) do
    Logger.error message
  end

  def report_status({:ok, :created, product}) do
    Logger.info fn -> {"product created:#{product.id}", [product: product]} end
  end

  def report_status({:ok, :updated, product}) do
    Logger.info fn -> {"product updated:#{product.id}", [product: product]} end
  end
  
  def report_status(_) do
    :noop
  end

  
  
  @doc """
    takes a single project and merges it in.
  """
  def merge_product(params, repo) do
    # find existing product with code and external product id
    case find_existing_product(params) |> repo.one() do
      nil ->
        create_product(params, repo) |> status_flag(:created)
      %Product{}=product ->
        update_product(product, params, repo) |> status_flag(:updated)
    end
  end

  #annotates the return so that we get a commit flag
  defp status_flag({:ok, value}, flag), do: {:ok, flag, value}
  defp status_flag(value, flag), do: value


  @docp """
    Takes a product and repo and creates the product in
    the system.

  """
  defp create_product(%{discontinued: true}, _) do
    {:skip, :discontinued}
  end
  defp create_product(params, repo) do
    repo.transaction(fn() ->
      new_product = Product.changeset(%Product{}, params)
                    |> repo.insert!()
                    |> repo.preload([:past_price_records])
      new_past_price_record = build_assoc(new_product, :past_price_records)
      |> PastPriceRecord.changeset(%{
          price: new_product.price,
          percentage_change: 100 # new prices are a 100% change
        })
      |> repo.insert!()
      new_product |> repo.preload([:past_price_records], force: true) #return the new product
    end)
  end

  @docp """
    Takes a product and repo and updates the product in
    the system if the name has not changed

  """
  defp update_product(product, params, repo) do
    #{:error, :not_implimented}
    if name_changed?(product, params) do
      {:error, :name_for_product_changed, %{
          id: product.id,
          from: Map.get(product, :product_name),
          to:  Map.get(params,  :name)
        }
      }
    else
      repo.transaction(fn() ->
        # get the most recent price record
        product = product |> repo.preload([:past_price_records])

        # not the optimal way of doing it but it'll do for now
        latest_record = product.past_price_records
          |> Enum.sort_by(fn(record) -> record.inserted_at end, &>=/2)
          |> Enum.at(0)

        # if this gets triggerred, something has messed with the database
        # in a way that voids the assumptions we make about the state
        # of the database. In such a case, it is prudent to raise an error
        # and stop operation till an engineer looks into it.
        if (latest_record.price !== product.price) do
          raise RuntimeError, message: "price record does not match current product"
        end

        #update the price
        product = Product.changeset(product, params) |> repo.update!()
        build_assoc(product, :past_price_records)
          |> PastPriceRecord.changeset(%{
               price: product.price,
               percentage_change: (params.price - latest_record.price)/latest_record.price
             })
          |> repo.insert!()
        product |> repo.preload([:past_price_records], force: true)
      end)
    end
  end

  defp price_changed?(product, params), do: product.price != params.price
  defp name_changed?(product, params),  do: product.product_name != params.product_name

  defp find_existing_product(product) do
    %{company_code: code, external_product_id: external_id} = product
    from(p in Product)
      |> where([p], p.company_code == ^code and p.external_product_id == ^external_id)
  end

end
